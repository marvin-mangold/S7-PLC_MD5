FUNCTION "MD5" : Void
TITLE = SHA1
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : MarvinMangold
FAMILY : Encrypt
NAME : '1'
VERSION : 0.1
//Sha1 is an cryptographic algorithm that takes a string of any length and reduces it to a unique fixed length string.
//
//Sha1 is not considered anymore as a secure hash type!
   VAR_INPUT 
      inputmode : Int;   // 1 = Bytes, 2 = String,
      outputmode : Int;   // 1 = digest,  2 = hexdigest , 3 = both
      messageBytes : Array[0..253] of Byte;   // message to be hashed as Bytes
      messageBytesLen : Int;   // number of used Bytes in messageBytes
      messageString : String;   // message to be hashed as String
   END_VAR

   VAR_OUTPUT 
      digest : Array[0..15] of Byte;   // hashed message as bytes
      hexdigest : String;   // hashed message as hex
   END_VAR

   VAR_TEMP 
      retval : Word;   // return value of functions
      cnt : Int;   // counter for the smaller loops
      empty : Bool;   // if the input is empty
      result_uppercase : String;   // hash result as uppercase Hex String
      result_lowercase : String;   // hash result as lowercase Hex String
      "char" : Char;   // char
      data : Struct   // message data
         "Byte" : Array[0..319] of Byte;   // message data in Bytes (max Byte length with a 254 char string is 320 Byte)
         "pointer" : Int;   // point to the actual array index
         length : Word;   // amount of bits in message
         checksize : Int;   // the actual amount of bits + the reserved 64 bits
         fitsize : Int;   // the needed amount of bits to save the checksize (multiple of 512)
         stringToCharsCnt : UInt;   // Strg_TO_Chars Output
      END_STRUCT;
      chunk : Struct   // chunkdata
         amount : DInt;   // amount of 512 bit parts from data (chunks)
         "counter" : Int;   // counter for the chunk loop
      END_STRUCT;
      F : DWord;   // bitwise variable
      A : DWord;   // initial variable (RFC1321)
      B : DWord;   // initial variable (RFC1321)
      C : DWord;   // initial variable (RFC1321)
      D : DWord;   // initial variable (RFC1321)
      AA : DWord;   // save 
      BB : DWord;
      CC : DWord;
      DD : DWord;
      G : Array[0..63] of Int;   // round constants
      M : Array[0..15] of DWord;   // chunk data 512 bit splitted  in 16 blocks
      S : Array[0..63] of Int;   // shift constants
      T : Array[0..63] of DWord;   // iteration constants
      TEMP : DWord;
      ROT : DWord;
      HH : Array[0..3] of String[8];   // Hash H0 - H4 each with 4 Byte/Char
   END_VAR


BEGIN
	REGION License and Information
	(*
	███╗   ███╗██████╗ ███████╗              ██████╗ ██╗      ██████╗
	████╗ ████║██╔══██╗██╔════╝              ██╔══██╗██║     ██╔════╝
	██╔████╔██║██║  ██║███████╗    █████╗    ██████╔╝██║     ██║     
	██║╚██╔╝██║██║  ██║╚════██║    ╚════╝    ██╔═══╝ ██║     ██║     
	██║ ╚═╝ ██║██████╔╝███████║              ██║     ███████╗╚██████╗
	╚═╝     ╚═╝╚═════╝ ╚══════╝              ╚═╝     ╚══════╝ ╚═════╝                                                                                      
	====================================================================================================================
	MIT License
	Copyright (C) 2025  Marvin Mangold (Marvin.Mangold00@googlemail.com)
	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:
	
	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.
	
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.
	====================================================================================================================
	The MD5 message-digest algorithm is a widely used hash function producing a 128-bit hash value.
	In this implmementation the string length is limited to a maximum length of 254 characters (String[254] - 2032 bit).
	
	The hashing is a one-way method making it almost impossible to decrypt. 
	MD5 is not considered anymore as a secure hash type!
	
	depending on the input "inputmode" different inputformats are used
	1   Message is used as Bytes
	2   Message is used as String
	
	depending on the input "outputmode" different outputformats are available
	1   The digest ouput is the final hash value as bytes of A - D (Array [0..15] of Byte)
	2   The hexdigest output is the final hash value as a hexadecimal string of A - D (32 bytes string)
	3   Both 1 and 2
	
	Step 00: Initialize variables
	Step 01: Convert and save message in data as Bytes
	Step 02: Appending padding Bits 
	Step 03: Append 64 Bit containg the original message length in Bits
	Step 04: Get the amount of chunks data (chunk = 512 Bit)
	FOR every chunk do Step 05 - Step 09:
	    Step 05: Save variables for later use
	    Step 06: Break the chunk into 16 DWords
	    Step 06: Initialize variables A - D
	    Step 07: Do some bitwise operations on the 16 chunk DWords in 64 rounds
	    Step 08: Save the chunk's hash TO result FOR the next chunk   
	Step 09: Produce "digest"
	Step 10: Produce "hexdigest"
	==================================================================================================================== 
	*)
	END_REGION
	
	REGION Step 00: Initialize variables A - D, iteration constants #T[0] - #T[63], shift constants #S[0] - #S[63], round constants #G[0] - #G[63]   
	    // initial variables (RFC1321)
	    #A := DW#16#6745_2301;
	    #B := DW#16#EFCD_AB89;
	    #C := DW#16#98BA_DCFE;
	    #D := DW#16#1032_5476;
	    
	    // iteration constants ( #T[i] = FLOOR( ABS( SIN(i) ) * 2^32 )
	    #T[0] :=  DW#16#D76A_A478;
	    #T[1] :=  DW#16#E8C7B_756;
	    #T[2] :=  DW#16#24207_0DB;
	    #T[3] :=  DW#16#C1BDC_EEE;
	    #T[4] :=  DW#16#F57C0_FAF;
	    #T[5] :=  DW#16#4787C_62A;
	    #T[6] :=  DW#16#A8304_613;
	    #T[7] :=  DW#16#FD469_501;
	    #T[8] :=  DW#16#69809_8D8;
	    #T[9] :=  DW#16#8B44F_7AF;
	    #T[10] := DW#16#FFFF_5BB1;
	    #T[11] := DW#16#895C_D7BE;
	    #T[12] := DW#16#6B90_1122;
	    #T[13] := DW#16#FD98_7193;
	    #T[14] := DW#16#A679_438E;
	    #T[15] := DW#16#49B4_0821;
	    #T[16] := DW#16#F61E_2562;
	    #T[17] := DW#16#C040_B340;
	    #T[18] := DW#16#265E_5A51;
	    #T[19] := DW#16#E9B6_C7AA;
	    #T[20] := DW#16#D62F_105D;
	    #T[21] := DW#16#0244_1453;
	    #T[22] := DW#16#D8A1_E681;
	    #T[23] := DW#16#E7D3_FBC8;
	    #T[24] := DW#16#21E1_CDE6;
	    #T[25] := DW#16#C337_07D6;
	    #T[26] := DW#16#F4D5_0D87;
	    #T[27] := DW#16#455A_14ED;
	    #T[28] := DW#16#A9E3_E905;
	    #T[29] := DW#16#FCEF_A3F8;
	    #T[30] := DW#16#676F_02D9;
	    #T[31] := DW#16#8D2A_4C8A;
	    #T[32] := DW#16#FFFA_3942;
	    #T[33] := DW#16#8771_F681;
	    #T[34] := DW#16#6D9D_6122;
	    #T[35] := DW#16#FDE5_380C;
	    #T[36] := DW#16#A4BE_EA44;
	    #T[37] := DW#16#4BDE_CFA9;
	    #T[38] := DW#16#F6BB_4B60;
	    #T[39] := DW#16#BEBF_BC70;
	    #T[40] := DW#16#289B_7EC6;
	    #T[41] := DW#16#EAA1_27FA;
	    #T[42] := DW#16#D4EF_3085;
	    #T[43] := DW#16#0488_1D05;
	    #T[44] := DW#16#D9D4_D039;
	    #T[45] := DW#16#E6DB_99E5;
	    #T[46] := DW#16#1FA2_7CF8;
	    #T[47] := DW#16#C4AC_5665;
	    #T[48] := DW#16#F429_2244;
	    #T[49] := DW#16#432A_FF97;
	    #T[50] := DW#16#AB94_23A7;
	    #T[51] := DW#16#FC93_A039;
	    #T[52] := DW#16#655B_59C3;
	    #T[53] := DW#16#8F0C_CC92;
	    #T[54] := DW#16#FFEF_F47D;
	    #T[55] := DW#16#8584_5DD1;
	    #T[56] := DW#16#6FA8_7E4F;
	    #T[57] := DW#16#FE2C_E6E0;
	    #T[58] := DW#16#A301_4314;
	    #T[59] := DW#16#4E08_11A1;
	    #T[60] := DW#16#F753_7E82;
	    #T[61] := DW#16#BD3A_F235;
	    #T[62] := DW#16#2AD7_D2BB;
	    #T[63] := DW#16#EB86_D391;
	    
	    // shift constants (RFC1321)
	    // 1 - 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22
	    // 2 - 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20
	    // 3 - 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23
	    // 4 - 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21
	    #S[0] := INT#7;
	    #S[1] := INT#12;
	    #S[2] := INT#17;
	    #S[3] := INT#22;
	    #S[4] := INT#7;
	    #S[5] := INT#12;
	    #S[6] := INT#17;
	    #S[7] := INT#22;
	    #S[8] := INT#7;
	    #S[9] := INT#12;
	    #S[10] := INT#17;
	    #S[11] := INT#22;
	    #S[12] := INT#7;
	    #S[13] := INT#12;
	    #S[14] := INT#17;
	    #S[15] := INT#22;
	    #S[16] := INT#5;
	    #S[17] := INT#9;
	    #S[18] := INT#14;
	    #S[19] := INT#20;
	    #S[20] := INT#5;
	    #S[21] := INT#9;
	    #S[22] := INT#14;
	    #S[23] := INT#20;
	    #S[24] := INT#5;
	    #S[25] := INT#9;
	    #S[26] := INT#14;
	    #S[27] := INT#20;
	    #S[28] := INT#5;
	    #S[29] := INT#9;
	    #S[30] := INT#14;
	    #S[31] := INT#20;
	    #S[32] := INT#4;
	    #S[33] := INT#11;
	    #S[34] := INT#16;
	    #S[35] := INT#23;
	    #S[36] := INT#4;
	    #S[37] := INT#11;
	    #S[38] := INT#16;
	    #S[39] := INT#23;
	    #S[40] := INT#4;
	    #S[41] := INT#11;
	    #S[42] := INT#16;
	    #S[43] := INT#23;
	    #S[44] := INT#4;
	    #S[45] := INT#11;
	    #S[46] := INT#16;
	    #S[47] := INT#23;
	    #S[48] := INT#6;
	    #S[49] := INT#10;
	    #S[50] := INT#15;
	    #S[51] := INT#21;
	    #S[52] := INT#6;
	    #S[53] := INT#10;
	    #S[54] := INT#15;
	    #S[55] := INT#21;
	    #S[56] := INT#6;
	    #S[57] := INT#10;
	    #S[58] := INT#15;
	    #S[59] := INT#21;
	    #S[60] := INT#6;
	    #S[61] := INT#10;
	    #S[62] := INT#15;
	    #S[63] := INT#21;
	    
	    // round constants
	    // round 0–15 → g = i
	    #G[0] := INT#0;
	    #G[1] := INT#1;
	    #G[2] := INT#2;
	    #G[3] := INT#3;
	    #G[4] := INT#4;
	    #G[5] := INT#5;
	    #G[6] := INT#6;
	    #G[7] := INT#7;
	    #G[8] := INT#8;
	    #G[9] := INT#9;
	    #G[10] := INT#10;
	    #G[11] := INT#11;
	    #G[12] := INT#12;
	    #G[13] := INT#13;
	    #G[14] := INT#14;
	    #G[15] := INT#15;
	    // round 16–31 → g = (5 * i + 1) mod 16
	    #G[16] := INT#1;
	    #G[17] := INT#6;
	    #G[18] := INT#11;
	    #G[19] := INT#0;
	    #G[20] := INT#5;
	    #G[21] := INT#10;
	    #G[22] := INT#15;
	    #G[23] := INT#4;
	    #G[24] := INT#9;
	    #G[25] := INT#14;
	    #G[26] := INT#3;
	    #G[27] := INT#8;
	    #G[28] := INT#13;
	    #G[29] := INT#2;
	    #G[30] := INT#7;
	    #G[31] := INT#12;
	    // round 32–47 → g = (3 * i + 5) mod 16
	    #G[32] := INT#5;
	    #G[33] := INT#8;
	    #G[34] := INT#11;
	    #G[35] := INT#14;
	    #G[36] := INT#1;
	    #G[37] := INT#4;
	    #G[38] := INT#7;
	    #G[39] := INT#10;
	    #G[40] := INT#13;
	    #G[41] := INT#0;
	    #G[42] := INT#3;
	    #G[43] := INT#6;
	    #G[44] := INT#9;
	    #G[45] := INT#12;
	    #G[46] := INT#15;
	    #G[47] := INT#2;
	    // round 48–63 → g = (7 * i) mod 16
	    #G[48] := INT#0;
	    #G[49] := INT#7;
	    #G[50] := INT#14;
	    #G[51] := INT#5;
	    #G[52] := INT#12;
	    #G[53] := INT#3;
	    #G[54] := INT#10;
	    #G[55] := INT#1;
	    #G[56] := INT#8;
	    #G[57] := INT#15;
	    #G[58] := INT#6;
	    #G[59] := INT#13;
	    #G[60] := INT#4;
	    #G[61] := INT#11;
	    #G[62] := INT#2;
	    #G[63] := INT#9;
	END_REGION
	
	REGION Step 01: Convert and save message in data as Bytes
	    // reset data
	    FILL_BLK(IN := 0, COUNT := 320, OUT => #data."Byte"[0]);
	    // save the number of Bytes filled in data in #data.stringToCharsCnt
	    IF #inputmode = 1 THEN
	        MOVE_BLK(IN := #messageBytes[0], COUNT := MIN(IN1 := #messageBytesLen, IN2 := 254), OUT => #data."Byte"[0]);
	        #data.stringToCharsCnt := INT_TO_UINT(MIN(IN1 := #messageBytesLen, IN2 := 254));
	    ELSIF #inputmode = 2 THEN
	        Strg_TO_Chars(Strg := #messageString, pChars := 0, Cnt => #data.stringToCharsCnt, Chars := #data."Byte");
	    END_IF;
	    #data."pointer" := UINT_TO_INT(#data.stringToCharsCnt);
	END_REGION
	
	REGION Step 02: Appending padding Bits 
	    // first append one "1" Bit at the end of the data
	    // then "0" Bits are appended to the data until the size of (512 Bit - 64 Bit) is reached
	    // the last 64 Bit are filled another way
	    // if the data is already > (512 Bit - 64 Bit) then fill until (1024 Bit - 64 Bit)...
	    // ...it has to be a (multiple of 512 Bit) - 64 Bit
	    
	    // append "1"
	    #data."Byte"[#data."pointer"] := B#2#10000000; // B#80; 
	    #data."pointer" += 1;
	    
	    // get the needed maximum size depending on actual amount of Bits + 64 Bits from message
	    #data.checksize := ((#data."pointer") * 8) + 64;
	    #empty := False;
	    IF 72 < #data.checksize AND #data.checksize <= 512 THEN
	        #data.fitsize := 512;
	    ELSIF 512 < #data.checksize AND #data.checksize <= 1024 THEN
	        #data.fitsize := 1024;
	    ELSIF 1024 < #data.checksize AND #data.checksize <= 1536 THEN
	        #data.fitsize := 1536;
	    ELSIF 1536 < #data.checksize AND #data.checksize <= 2048 THEN
	        #data.fitsize := 2048;
	    ELSIF 2048 < #data.checksize AND #data.checksize <= 2560 THEN
	        #data.fitsize := 2560;
	        // if there is an empty string, the checksize will be 8 Bit (the appended B#80) + 64 Bit = 72 Bit
	    ELSE
	        #empty := True;
	    END_IF;
	    
	    // append the "0"s until the fitsize (minus the reserved 64 Bit) is reached
	    FOR #cnt := (#data."pointer") TO ((#data.fitsize - 64) / 8) - 1 DO
	        #data."Byte"[#cnt] := B#2#00000000; // B#00;
	        #data."pointer" := #cnt;
	    END_FOR;
	END_REGION
	
	REGION Step 03: Append 64 Bit containg the original message length in Bits
	    // 'Test' = 32 Bits --> B#2#00100000_00000000_00000000_00000000_00000000_00000000_00000000_00000000
	    // the maximum amount of Bits is: 254 Bytes * 8 --> 2032 --> this fits in a Word
	    // so append 6 Bytes with B#00 after the Word
	    // get length of message in Word
	    #data."length" := INT_TO_WORD(UINT_TO_INT(#data.stringToCharsCnt) * 8);
	    #data."Byte"[#data."pointer" + 1] := #data."length".%B0;
	    #data."Byte"[#data."pointer" + 2] := #data."length".%B1;
	    #data."Byte"[#data."pointer" + 3] := B#2#00000000; // B#00;
	    #data."Byte"[#data."pointer" + 4] := B#2#00000000; // B#00;
	    #data."Byte"[#data."pointer" + 5] := B#2#00000000; // B#00;
	    #data."Byte"[#data."pointer" + 6] := B#2#00000000; // B#00;
	    #data."Byte"[#data."pointer" + 7] := B#2#00000000; // B#00;
	    #data."Byte"[#data."pointer" + 8] := B#2#00000000; // B#00;
	    #data."pointer" += 8;
	END_REGION
	
	REGION Step 04: Get the amount of chunks data (chunk = 512 Bit)
	    #chunk.amount := CEIL((#data."pointer" + 1) * 8 / 512);
	END_REGION
	
	REGION FOR every chunk do Step 05 - Step 09:
	    // reset data pointer
	    #data."pointer" := 0;
	    
	    //  for every chunk do
	    FOR #chunk.counter := 0 TO #chunk.amount - 1 DO
	        // clear chunkdata
	        FILL_BLK(IN := DW#16#0000_0000, COUNT := 15, OUT => #M[0]);
	        
	        REGION Step 05: Save variables for later use
	            // save A B C D in AA BB CC DD
	            #AA := #A;
	            #BB := #B;
	            #CC := #C;
	            #DD := #D;
	        END_REGION
	        
	        REGION Step 06: Break the chunk into 16 DWords
	            FOR #cnt := 0 TO 15 DO
	                #M[#cnt].%B0 := #data."Byte"[#data."pointer" + 0];
	                #M[#cnt].%B1 := #data."Byte"[#data."pointer" + 1];
	                #M[#cnt].%B2 := #data."Byte"[#data."pointer" + 2];
	                #M[#cnt].%B3 := #data."Byte"[#data."pointer" + 3];
	                #data."pointer" += 4;
	            END_FOR;
	        END_REGION
	        
	        REGION Step 07: Do some bitwise operations on the 16 chunk DWords in 64 rounds           
	            FOR #cnt := 0 TO 63 DO
	                // do bitwise operation depending on the DWord to get F
	                IF 0 <= #cnt AND #cnt <= 15 THEN
	                    #F := (#B AND #C) OR ((NOT #B) AND #D);
	                ELSIF 16 <= #cnt AND #cnt <= 31 THEN
	                    #F := (#D AND #B) OR ((NOT #D) AND #C);
	                ELSIF 32 <= #cnt AND #cnt <= 47 THEN
	                    #F := #B XOR #C XOR #D;
	                ELSIF 48 <= #cnt AND #cnt <= 63 THEN
	                    #F := #C XOR (#B OR (NOT #D));
	                END_IF;
	                
	                // calculate TEMP
	                // #TEMP := #A + #F + #T[i] + M[#G[i]];
	                #TEMP := #A + #F + #T[#cnt] + #M[#G[#cnt]];
	
	                // rotation
	                // #ROT := ROL(temp, S[i]);
	                #ROT := ROL_DWORD(IN :=#TEMP, N := INT_TO_UDINT(#S[#cnt]));
	               
	                // refresh variables
	                #TEMP := #D;
	                #D := #C;
	                #C := #B;
	                #B := #B + #ROT;
	                #A := #TEMP;
	            END_FOR;
	        END_REGION
	        
	        REGION Step 08: Save the chunk's hash TO result FOR the next chunk   
	            #A := #A + #AA;
	            #B := #B + #BB;
	            #C := #C + #CC;
	            #D := #D + #DD;
	        END_REGION
	    END_FOR;
	END_REGION
	
	REGION Step 09: Produce "digest"
	    IF #outputmode = 1 OR #outputmode = 3 THEN
	        // the final hash value as bytes of A - D (Array [0..15] of Byte
	        // A = 16#A9_4A_8F_E5
	        // B = 16#CC_B1_9B_A6
	        // C = 16#1C_4C_08_73
	        // D = 16#D3_91_E9_87
	        
	        #digest[0] := #A.%B3;
	        #digest[1] := #A.%B2;
	        #digest[2] := #A.%B1;
	        #digest[3] := #A.%B0;
	        
	        #digest[4] := #B.%B3;
	        #digest[5] := #B.%B2;
	        #digest[6] := #B.%B1;
	        #digest[7] := #B.%B0;
	        
	        #digest[8] := #C.%B3;
	        #digest[9] := #C.%B2;
	        #digest[10] := #C.%B1;
	        #digest[11] := #C.%B0;
	        
	        #digest[12] := #D.%B3;
	        #digest[13] := #D.%B2;
	        #digest[14] := #D.%B1;
	        #digest[15] := #D.%B0;
	    ELSE
	        FILL_BLK(IN := 0, COUNT := 16, OUT => #digest[0]);
	    END_IF;
	END_REGION
	
	REGION Step 10: Produce "hexdigest"
	    IF #outputmode = 2 OR #outputmode = 3 THEN
	        // the final hash value as a hexadecimal string of A - D (32 bytes string)
	        // A = 16#A94A_8FE5
	        // B = 16#CCB1_9BA6
	        // C = 16#1C4C_0873
	        // D = 16#D391_E987
	        
	        // turn A - D in a Hexadecimal String
	        // A = 16#A94A_8FE5
	        // B = 16#CCB1_9BA6
	        // C = 16#1C4C_0873
	        // D = 16#D391_E987
	        // 
	        // A = 'A94A8FE5'
	        // B = 'CCB19BA6'
	        // C = '1C4C0873'
	        // D = 'D391E987'
	      
	        #retval := HTA(IN := #A, N := 4, OUT => #HH[0]);
	        #retval := HTA(IN := #B, N := 4, OUT => #HH[1]);
	        #retval := HTA(IN := #C, N := 4, OUT => #HH[2]);
	        #retval := HTA(IN := #D, N := 4, OUT => #HH[3]);
	        
	        // concat A - D
	        // A94A8FE5CCB19BA61C4C0873D391E987
	        #result_uppercase := CONCAT_STRING(IN1 := '', IN2 := #HH[0]);
	        #result_uppercase := CONCAT_STRING(IN1 := #result_uppercase, IN2 := #HH[1]);
	        #result_uppercase := CONCAT_STRING(IN1 := #result_uppercase, IN2 := #HH[2]);
	        #result_uppercase := CONCAT_STRING(IN1 := #result_uppercase, IN2 := #HH[3]);
	        
	        // turn uppercase letters to lowercase letters
	        // a94a8fe5ccb19ba61c4c0873d391e987
	        #hexdigest := '';
	        FOR #cnt := 1 TO LEN(#result_uppercase) DO
	            // check if actual char is A - F (A = 65, F = 70) and turn it to a - f (97 - 102)
	            IF CHAR_TO_BYTE(#result_uppercase[#cnt]) >= 65 AND CHAR_TO_BYTE(#result_uppercase[#cnt]) <= 70 THEN
	                // turn uppercase letter to lowercase letter
	                #char := BYTE_TO_CHAR(CHAR_TO_BYTE(#result_uppercase[#cnt]) + 32);
	                #result_lowercase := CONCAT_STRING(IN1 := #result_lowercase, IN2 := #char);
	            ELSE
	                #result_lowercase := CONCAT_STRING(IN1 := #result_lowercase, IN2 := #result_uppercase[#cnt]);
	            END_IF;
	        END_FOR;
	        #hexdigest := #result_lowercase;
	    ELSE
	        #hexdigest := '';
	    END_IF;
	END_REGION
	
	IF #empty THEN
	    FILL_BLK(IN := 0, COUNT := 16, OUT => #digest[0]);
	    #hexdigest := '';
	END_IF;
END_FUNCTION

